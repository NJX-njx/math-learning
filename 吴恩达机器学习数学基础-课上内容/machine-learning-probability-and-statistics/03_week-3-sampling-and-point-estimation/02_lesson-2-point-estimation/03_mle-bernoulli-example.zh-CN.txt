让我们回到硬币的例子。 假设你投掷一枚硬币十次， 它落在正面八次，落在反面两次。 现在你有三种可能的硬币可以翻转来得到这些结果。 硬币一的正面概率为0.7， 硬币二是公平的硬币，正面和 反面的概率为0.5，硬币三的正面概率为0.3。 现在，你认为这10次投掷中使用的硬币是哪一枚呢？ 或者至少如果你的目标是 再次产生这 10 次投掷，你会使用哪一个？ 好吧，让我们来看看硬币 每枚硬币落在八个正面和两个反面的概率。 对于硬币来说，一是0.7乘以8乘以0.3平方的乘积，即0.0051。 它很小。 但是让我们来看看硬币 2，硬币 2 是 0.5 比 10，也就是 0.0010，要小得多。 硬币三是所有正面的 0.3 比 7， 反面是 0.7 平方，也就是 0.00003。 那非常、非常小。 其实最大的是这里的这个。 因此，我们得出的结论是，如果我们必须从三种硬币中选择一种，我们 可能应该选择硬币一作为最有可能产生这种硬币的硬币。 我们在这里所做的可能性很大。 我们想生成 8 个正面、2 个反面，有三种可能的硬 币可以生成硬币 1 个正面概率为 0.7，硬币有 0.5 的正面概率为 0.5，硬币三的正面概率为 0.3。 而且每个人都有一定的概率生成了数据。 现在，最有可能产生 8 个正面和 2 个反面的硬币是什么？ 好吧，是最大限度地提高 给定硬币8正2反的概率的那个，这是第一个，因为这个 条件概率对于一枚硬币来说是最高的。 因此，这就是我们选择的那个。 但是我们能做得更好吗？ 有更好的硬币可能起作用吗？ 假设我们选了一些硬币的正面概率为 P， 反面概率为 1-P， 那么这枚硬币产生八个正面和两个反面的概率是多少？ 好吧，它是 P 到 8 乘以 1-P 的平方，也就是那个乘积。 现在我们想要能够最大限度地提高看见 8 个正面和 2 个反面机会的 P。 这就是可能性。 可能性是根据模型看到 这些数据的概率，这是一个概率为P的硬币。 请注意，这是P的函数，因此我们必须将其最大化。 这是我们在微积分课上看到的一个例子， 事实证明我们不想处理很多事物的乘积， 尤其是当我们谈论小数时。 让我们 以对数为例，这是我们用来将乘积转换为和的非常标准的技巧，它将乘积P转换为 8倍（1-P）的平方变为8对数（P）+ 2对数（1-P）。 这就是对数可能性。 因此，很多时候我们不会尝试最大限度地提高可能性，而是 要最大限度地提高对数可能性。 最大化一个与最大化另一个相同，但对 数似然性通常是一个更好的函数。 因此，当我们取对数可能性 P 的导数时， 我们就会得到这个。 请记住，P 对数的导数是 P 上的 1。 对于第二个项，我们有一个链式法则， 负一来自该链式法则。 如果我们想让它等于 0， 那么最佳值是 P hat 等于 8 而不是 10。 因此，实际上，产生这种翻转的最好的 硬币是正面概率为8而不是10％或80％的硬币。 这是有道理的，对吧？ 因为数据有 8 个正面和 2 个反面。 对于一般情况，让我们做一些数学运算。 假设你有 n 个硬币和 k 个正面， 每个硬币都是一个带有参数 P 的伯努利变量 ，这意味着它有 P 落在正面中的概率。 这个公式给出了可能性， 它是 P 到 xi 1-P 到 1-xi 的乘积。也@@ 就是说，如果 xi 等于 1 我们有 P， 如果 xi 等于 0，那么我们有 1-P。 现在这是正面的数量，这是反面的数量。 因此，我们可以这样分解这个表达式。 现在，对数可能性将是它的对数， 指数向下移动，我们得到这个表达式。 我们想最大化这个表达式， 我们所要做的就是取导数并将其设置为 0。 这给了我们 P hat 的最佳值， 这正是总体的平均值。 因此，换句话说，例如，如果我们在这些硬币中有 k 个正面， 那么获得这些 k 个正面的最佳概率恰好是 k 大于 n。