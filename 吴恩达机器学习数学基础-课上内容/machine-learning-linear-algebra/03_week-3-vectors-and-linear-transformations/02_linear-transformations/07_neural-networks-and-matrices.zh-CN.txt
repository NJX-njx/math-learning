现在来看看机器学习应用程序。 回想一下第一周，神经网络是目前最成功、最 强大的机器学习模型之一，有许多应用， 它主要基于矩阵和矩阵乘积。 让我给你看一个具体的例子，说明一个简单的神经网络， 它实际上可以与点积一起使用。 >> 首先，让我们从一个小测验开始。 想象一下，你有一个垃圾邮件数据集，在垃圾邮件数据集中，你精确定了 两个对垃圾邮件非常有确定性的单词，即抽奖和中奖这两个词。 它们似乎更多地出现在垃圾邮件中， 但当然，它们的出现并不能保证电子邮件是垃圾邮件。 因此，你已经计算了电子邮件中出现的垃圾邮件 而不是垃圾邮件的次数，并得到了这张表。 现在的目标如下。 你想建立一个垃圾邮件过滤器，尽可能好的垃圾邮件过滤器。 这就是所谓的分类器，它是一种神经机器，它会尝试 根据此表的内容来猜测电子邮件是否为垃圾邮件。 这个特定的分类器将按以下方式工作。 你为单词抽奖分配分数，为单词获胜分配分数， 然后通过将 重复的单词分数相加来计算句子的分数。 例如，如果 “彩票” 和 “赢” 这两个词的分数是三和二， 那么句子 “win win the lottery” 的总分为七分。 每次出现中奖两个，彩票出现三个， 单词出现时没有一个，那个。 现在，猜测电子邮件是否为垃圾邮件的规则如下。 如果句子的分数大于 某个称为阈值的分数，则该电子邮件将被归类为垃圾邮件，否则不是。 注意，这并不意味着电子邮件是垃圾邮件， 只是意味着分类器认为它是垃圾邮件并将其发送到垃圾邮件箱。 现在，测验的目标是找到尽可能好的分类器， 这意味着一个尽可能符合表格结果的分类器。 换句话说，你想找到单词 “彩票” 、“中奖” 和 “阈值” 的最佳分数，这样 分类器的结果就尽可能接近表格的垃圾邮件列。 我会给你一个提示，实际上可以找到三个数字 ，这样分类器就可以对表格中的每封电子邮件做出正确的猜测， 试一试。 答案在这里，实际上很多答案都有效，但 是在测验的选项中，唯一有效的就是这个。 彩票、中奖这两个词的分数均为一分 ，门槛为1.5分。 请注意，当你计算句子的分数时， 它们最终是每个单词出现的次数之和。 而且，当你检查大于或等于阈值1.5的数字时， 答案列与电子邮件是否为垃圾邮件时追索的列完全相同。 因此，这是该特定数据集的完美垃圾邮件过滤器。 这意味着分类器 在给出的数据集中做得相当不错。 现在，这被称为自然语言处理，因为输入的是语言， 它是单词，它使用这些词来做出预测。 这个分类器也可以以图形方式看出，如下所示。 让我们在一个平面上绘制数据集，在该平面中，水平轴， 彩票单词出现的次数，垂直轴，即 中奖单词出现的次数。 所以数据集看起来像这样。 请注意，它非常特别，因为一条线可以将垃圾邮件和非垃圾邮件区分开来。 此外，这条线恰好由分数和 阈值给出的方程式，即1次中奖加上1次彩票等于1.5。 这条线还产生了两个区域，正区域和负区域。 正区域是句子分数大于 阈值的区域，负数区域 是句子分数小于阈值的区域。 这正是分类器，一个线性分类器， 它实际上是最简单的神经网络，它是一个只有一层的神经网络。 还要知道这个模型确实有道理， “抽奖” 和 “中 奖” 这两个词出现的次数越多，句子中的分数就越高，电子邮件成为垃圾邮件的可能性就越大。 单层神经网络可以看作是矩阵乘积，然后 是阈值检查。 在这里，左边是数据集，中间是 模型，这两个数字 1,1 是 “彩票” 和 “中奖” 这两个词的分数。 现在让我们来看看其中一行，比如第二行，这是一句话，里面 有两次出现世界彩票，一次出现了 “赢” 一词。 现在，为了找到该句子的分数，[听不清] 只需取 句子行和模型列的点积，即可得到二加一等于三。 现在，在点积之后，你可以用阈值进行检查。 如果结果大于 1.5，则返回 “是”，如果不是，则返回 “否”， 在本例中为 3 大于 1.5，因此预测是垃圾邮件， 这意味着机密人员认为电子邮件是垃圾邮件，这是正确的。 让我们再做一个，比如第五排。 这个只有一个出现 “赢” 一词， 没有出现彩票这个词。 点积等于检查后预测为 “否” 的乘积， 因为分类器认为电子邮件不是垃圾邮件，而且又是正确的。 现在，请注意，如果你有更多的单词， 你只需要在左边有一个宽得多的矩阵， 右边有一个长得多的模型向量，但这仍然有效。 现在，同时进行所有这些预测的一种更简单的方法 是实际取矩阵和向量的乘积。 因此，如果我们取矩阵和这个向量的乘积， 我们得到分数的向量，我们所要做的就是对 这个向量中的所有元素进行校验以获得我们的预测。 正如我之前提到的，如果你有很多单词，你只需要一个宽得多的 矩阵和一个更长的模型向量，但这会完全相同。 但现在让我们回到两栏案例。 这是另一种看待这个分类器的方法。 检查垃圾邮件的公式 是，句子的分数大于阈值，即1.5。 但这与说分数减去1.5大于零是一样的， 在本例中，这个负1.5被称为偏差。 因此，将其包含在矩阵乘法中的方法是将 数据表中数字为第一的整列相加，并在模型中将 偏差为-1.5的滚动相加。 现在， 我们不必检查结果是否大于阈值，而只需要检查修改后的分数是正数还是负数。 这给了我们完全相同的分类器， 有时你会看到分类器有偏差，有时会有阈值。 对于更复杂的神经网络，偏差往往更为常见。 但是，我们不要太担心偏见，而是继续使用阈值， 而是让我们来看一个更简单的问题。 这叫做 AND 运算符，数据集实际上非常相似， 它只是之前数据集的四行，标签和以前相同， 只是现在它不是垃圾邮件或不是垃圾邮件问题。 现在，如果 x 和 y 列都包含一个，则 AND 列只会说 “是”，否则则说 “否”。 这只是两个元素的众所周知的 AND 运算符。 现在，我为什么要提起 AND 运算符？ 因为如果你将其视为一个小数据集，那么你可以使用 神经网络对其进行建模，实际上与你用于垃圾邮件检测器的神经网络完全相同。 当你将矩阵乘以这个模型向量时，你会得到这些结果， 当你使用与以前相同的阈值进行检查时， 你得到的预测看起来与 AND 数据集完全一样。 因此，AND 数据集可以建模为感知，作为单层神经网络。 从图形上看，这是一个分类器，请注意，这条线与之前 分隔点的线完全相同，唯一的不同是，现在只有点的子集。 直线方程是一样的， x 乘以一乘以 y 减去 1.5 等于零。 这是一种表示之前的 AND 感知的图形方式。 输入为 x 和 y，偏差为负 1.5。 在此图中，节点内部的数字 乘以边的权重，然后将其添加到下一个节点中。 然后应用激活函数， 激活正是支票，如果得到的不是负数， 则是返回 1 或 “是” 的函数；如果出现的是负数，则返回零或否。 使用变量，这就是实验室中出现的感知。 输入是来自数据集的 x， 模型的权重是 ws，偏差是 b。在 节点内部，会出现与偏差相加的点积。 然后，节点的输出通过激活函数 ，从而生成感知的输出